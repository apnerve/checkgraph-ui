// Generated by CoffeeScript 1.3.3
var CheckGraph;

CheckGraph = (function() {
  var graphId, handleGraphics, initGraph, initTasksObj, isAcyclic, levels, markTaskAs, populateLevels, tasks, tasksCount, title, urls;

  urls = {
    addChild: function(parentId, childId) {
      return "addChild.html?&graph_id=" + graphId + "&parent_id=" + parentId + "&child_id" + childId;
    },
    changeStatus: function(taskId, status) {
      return "changeStatus.php?&graph_id=" + graphId + "&task_id=" + taskId + "&status=" + status;
    }
  };

  graphId = null;

  title = null;

  tasks = {};

  tasksCount = 0;

  levels = [];

  markTaskAs = function(taskId, newStatus) {
    var checkIfOpen, markTaskAsDone, oldStatus;
    checkIfOpen = function(taskId) {
      var id, isOpen, shouldMarkFalse, task;
      isOpen = true;
      shouldMarkFalse = function(parentId, parent) {
        var child, isParent, markParent, _i, _len, _ref;
        markParent = function(childId) {
          var isParent;
          if (childId === taskId) {
            return isParent = true;
          }
        };
        isParent = false;
        _ref = parent.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          markParent(child.id);
        }
        if (isParent && parent.status !== "DONE") {
          return isOpen = false;
        }
      };
      for (id in tasks) {
        task = tasks[id];
        shouldMarkFalse(id, task);
      }
      if (isOpen && !tasks[taskId].isOpen) {
        tasks[taskId].isOpen = true;
        tasks[taskId].DOMItem.addClass("open-task");
        tasks[taskId].DOMItem.addClass("red");
        return tasks[taskId].DOMItem.removeClass("yellow");
      }
    };
    markTaskAsDone = function() {
      return $.ajax({
        url: urls.changeStatus(taskId, "DONE"),
        method: "GET",
        success: function(response) {
          var child, _i, _len, _ref, _results;
          console.log("Marked Done");
          tasks[taskId].status = "DONE";
          tasks[taskId].DOMItem.addClass("done-task");
          tasks[taskId].DOMItem.addClass("blue");
          tasks[taskId].DOMItem.removeClass("open-task");
          tasks[taskId].DOMItem.removeClass("red");
          _ref = tasks[taskId].children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            _results.push(checkIfOpen(child.id));
          }
          return _results;
        },
        error: function(response) {
          return console.log("Unable to Mark Done");
        },
        complete: function(response) {
          return console.log("Completed");
        }
      });
    };
    oldStatus = tasks[taskId].status;
    if (oldStatus !== newStatus) {
      if (oldStatus === "NOT_DONE" && tasks[taskId].isOpen && newStatus === "DONE") {
        return markTaskAsDone();
      }
    }
  };

  initTasksObj = function(taskList) {
    var addTask, task, _i, _len, _results;
    tasksCount = taskList.length;
    addTask = function(task) {
      return tasks[task.id] = task;
    };
    _results = [];
    for (_i = 0, _len = taskList.length; _i < _len; _i++) {
      task = taskList[_i];
      _results.push(addTask(task));
    }
    return _results;
  };

  populateLevels = function() {
    var id, initTask, isLeveled, leveledCount, markThisLevel, markUsingTask, num, remarkTasks, task, taskStatus;
    taskStatus = {};
    isLeveled = {};
    levels = [];
    leveledCount = 0;
    markUsingTask = function(id, task) {
      var child, lockTask, markAs, _i, _j, _len, _len1, _ref, _ref1, _results;
      markAs = function(task_id, isParent) {
        if (!(taskStatus[task_id] != null)) {
          return taskStatus[task_id] = isParent ? "Parent" : "Child";
        } else if (taskStatus[task_id] === "Parent" && isParent === false) {
          return taskStatus[task_id] = "Child";
        }
      };
      lockTask = function(task_id) {
        return tasks[task_id].isOpen = false;
      };
      if (taskStatus[id] === "Leveled") {
        return;
      }
      markAs(id, true);
      _ref = task.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        markAs(child.id, false);
      }
      if (task.status === "NOT_DONE") {
        _ref1 = task.children;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          child = _ref1[_j];
          _results.push(lockTask(child.id));
        }
        return _results;
      }
    };
    remarkTasks = function() {
      var id, remark, task, _results;
      remark = function(id) {
        if (taskStatus[id] !== "Leveled") {
          return taskStatus[id] = "Parent";
        }
      };
      _results = [];
      for (id in taskStatus) {
        task = taskStatus[id];
        _results.push(remark(id));
      }
      return _results;
    };
    markThisLevel = function() {
      var handleTaskLeveling, id, status, thisLevel;
      thisLevel = [];
      handleTaskLeveling = function(task_id, status) {
        if (status === "Parent") {
          thisLevel.push(task_id);
          return taskStatus[task_id] = "Leveled";
        }
      };
      for (id in taskStatus) {
        status = taskStatus[id];
        handleTaskLeveling(id, status);
      }
      levels.push(thisLevel);
      leveledCount = leveledCount + thisLevel.length;
      return thisLevel.length;
    };
    initTask = function(id) {
      isLeveled[id] = false;
      return tasks[id].isOpen = true;
    };
    for (id in tasks) {
      task = tasks[id];
      initTask(id);
    }
    while (leveledCount < tasksCount) {
      for (id in tasks) {
        task = tasks[id];
        markUsingTask(id, task);
      }
      num = markThisLevel();
      if (num === 0) {
        console.log("This is a cyclic graph.");
        return false;
      }
      remarkTasks();
    }
    return true;
  };

  handleGraphics = function() {
    var addChildConnection, addConnectionOnServer, canvasWidth, connectionClickHandle, connectionClickStatus, dataContainer, drawLevel, height, id, level, paper, task, width, xOffSet, xSpace, yOffSet, ySpace, yTextOffSet, _i, _len, _results;
    canvasWidth = levels.length * 470;
    $("#background-canvas").empty();
    $("#foreground-data").empty();
    paper = Raphael("background-canvas", "" + canvasWidth + "px", "100%");
    height = 80;
    width = 340;
    xSpace = 130;
    ySpace = 30;
    xOffSet = 60;
    yOffSet = ySpace;
    yTextOffSet = 30;
    dataContainer = $("#foreground-data");
    connectionClickStatus = {
      active: false,
      taskId: null,
      type: null
    };
    addConnectionOnServer = function(parentId, childId) {
      var errorHandle;
      errorHandle = function(response) {
        console.log("Error");
        console.log(response);
        return tasks[parentId].children = tasks[parentId].children.slice(0, tasks[parentId].children.length - 1);
      };
      return $.ajax({
        url: urls.addChild(parentId, childId),
        method: 'get',
        success: function(response) {
          if (response.status === 200 || true) {
            paper.connection(tasks[parentId].Raphael.rObj, tasks[childId].Raphael.rObj, 2, "#400");
            console.log("success");
          } else {
            errorHandle(response);
          }
          return console.log(response);
        },
        complete: $(".ButtonSelected").removeClass("ButtonSelected"),
        error: function(response) {
          return errorHandle(response);
        }
      });
    };
    connectionClickHandle = function(taskId, type) {
      var childId, newChildRef, parentId;
      if (!connectionClickStatus.active) {
        connectionClickStatus.active = true;
        connectionClickStatus.taskId = taskId;
        return connectionClickStatus.type = type;
      } else {
        if (connectionClickStatus.type === type) {
          console.log("Same Type! Couldn't connect");
        } else if (connectionClickStatus.taskId === taskId) {
          console.log("Same Task! Couldn't connect");
        } else {
          parentId = type === "right" ? taskId : connectionClickStatus.taskId;
          childId = type === "left" ? taskId : connectionClickStatus.taskId;
          newChildRef = {
            id: childId
          };
          tasks[parentId].children.push(newChildRef);
          if (populateLevels()) {
            addConnectionOnServer(parentId, childId);
          } else {
            tasks[parentId].children = tasks[parentId].children.slice(0, tasks[parentId].children.length - 1);
            $(".ButtonSelected").removeClass("ButtonSelected");
          }
        }
        return connectionClickStatus.active = false;
      }
    };
    drawLevel = function(level) {
      var column, drawTask, taskId, _i, _len;
      yOffSet = ySpace;
      column = $("<div></div>").addClass("takswrap");
      dataContainer.append(column);
      drawTask = function(taskId) {
        var doneLink, item, leftLinks, rightLinks;
        item = $("<div></div>").addClass("todo-app");
        item.append($("<div class='maintask'>" + tasks[taskId].title + "</div>"));
        tasks[taskId].DOMItem = item;
        if (tasks[taskId].isOpen) {
          item.addClass("open-task");
          item.addClass("red");
        } else {
          item.addClass("yellow");
        }
        if (tasks[taskId].status === "DONE") {
          item.addClass("done-task");
          item.addClass("blue");
        }
        doneLink = function() {
          var con, doneButton;
          con = $("<div></div>").addClass("actions");
          doneButton = function() {
            var but;
            but = $("<input type='submit' value='Done'>");
            return but.click(function() {
              return markTaskAs(taskId, "DONE");
            });
          };
          con.append(doneButton());
          return con;
        };
        rightLinks = function() {
          var con, rightArrow, rightButton;
          con = $("<div class='addLinks'></div>");
          rightArrow = function() {
            var ele;
            ele = $('<input type="submit" value=">" />');
            ele.click(function() {
              ele.addClass("ButtonSelected");
              return connectionClickHandle(taskId, "right");
            });
            return ele;
          };
          rightButton = function() {
            return $('<input type="submit" value="+" />');
          };
          con.append(rightArrow());
          con.append(rightButton());
          return con;
        };
        leftLinks = function() {
          var con, leftArrow, leftButton;
          leftArrow = function() {
            var ele;
            ele = $('<input type="submit" value="<" />');
            ele.click(function() {
              ele.addClass("ButtonSelected");
              return connectionClickHandle(taskId, "left");
            });
            return ele;
          };
          leftButton = function() {
            return $('<input type="submit" value="+" />');
          };
          con = $("<div class='addLinks leftlink'></div>");
          con.append(leftArrow());
          return con.append(leftButton());
        };
        item.append(doneLink());
        item.append(rightLinks());
        item.append(leftLinks());
        tasks[taskId].Raphael = {
          rObj: paper.rect(xOffSet, yOffSet, width, height),
          taskDataItem: item
        };
        yOffSet = yOffSet + height + ySpace;
        return column.append(item);
      };
      for (_i = 0, _len = level.length; _i < _len; _i++) {
        taskId = level[_i];
        drawTask(taskId);
      }
      return xOffSet = xOffSet + width + xSpace;
    };
    addChildConnection = function(id, task) {
      var addConnection, child, _i, _len, _ref, _results;
      addConnection = function(obj1, obj2) {
        return paper.connection(obj1, obj2, 2, "#400");
      };
      _ref = task.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        _results.push(addConnection(task.Raphael.rObj, tasks[child.id].Raphael.rObj));
      }
      return _results;
    };
    for (_i = 0, _len = levels.length; _i < _len; _i++) {
      level = levels[_i];
      drawLevel(level);
    }
    _results = [];
    for (id in tasks) {
      task = tasks[id];
      _results.push(addChildConnection(id, task));
    }
    return _results;
  };

  initGraph = function() {
    populateLevels();
    return window.onload = function() {
      return handleGraphics();
    };
  };

  isAcyclic = function() {};

  function CheckGraph(graphObj) {
    title = graphObj.title;
    initTasksObj(graphObj.tasks);
    initGraph();
  }

  return CheckGraph;

})();
